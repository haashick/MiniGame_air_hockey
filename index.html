<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>모바일 에어하키 (Player vs AI)</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 사용 설정 (Tailwind 기본 폰트) */
        :root {
            --board-color: #0b1c31; /* 진한 남색 배경 */
            --line-color: #2a588b; /* 보드 라인 색상 */
            --player-color: #4a90e2; /* 플레이어 패들 (파란색) */
            --ai-color: #e24a4a; /* AI 패들 (빨간색) */
            --puck-color: #e6e6e6; /* 퍽 색상 */
            --max-velocity: 15;
            font-family: 'Inter', sans-serif;
        }

        body {
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            padding: 5px;
            margin: 0;
            overflow-x: hidden;
        }

        #gameControls {
            width: 100%;
            max-width: 90vw;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            margin-bottom: 8px;
            color: white;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
        }

        #gameContainer {
            width: 100%;
            max-width: min(90vw, 90vh * 0.67); /* 화면 크기에 따라 동적 조절 */
            aspect-ratio: 1 / 1.5; /* 에어하키 테이블 비율 유지 */
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 1rem;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            background-color: var(--board-color);
            margin: 0 auto;
        }

        canvas {
            background-color: var(--board-color);
            border-radius: 1rem;
            touch-action: none; /* 모바일에서 기본 스크롤 동작 방지 */
        }

        #scoreBoard {
            padding: clamp(0.5rem, 2vw, 0.75rem);
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: clamp(1rem, 4vw, 1.5rem);
            font-weight: 700;
        }

        .score-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #aiScore { color: var(--ai-color); }
        #playerScore { color: var(--player-color); }

        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            display: none;
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .action-button {
            margin-top: clamp(8px, 2vw, 15px);
            padding: clamp(6px, 2vw, 10px) clamp(12px, 3vw, 20px);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px #00000030;
        }

        .action-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #00000030;
        }

        #restartButton {
            background-color: #4CAF50; /* Green */
            color: white;
        }

        #restartButton:hover {
            background-color: #45a049;
        }
        
        /* 라운드 재시작 버튼의 커스텀 CSS는 Tailwind 클래스로 대체 */

        /* 전체 재시작 버튼의 커스텀 CSS는 Tailwind 클래스로 대체 */

        #difficultySelect {
            padding: clamp(4px, 1vw, 5px) clamp(8px, 2vw, 10px);
            border-radius: 5px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
        }

        /* 모바일 최적화 */
        @media (max-width: 768px) {
            body {
                padding: 2px;
            }
            
            #gameControls {
                flex-direction: column;
                gap: 8px;
                align-items: center;
            }
            
            #gameControls .flex {
                justify-content: center;
                gap: 8px;
            }
        }

        /* 매우 작은 화면 대응 */
        @media (max-width: 480px) {
            #gameContainer {
                max-width: 95vw;
            }
            
            .action-button {
                padding: 8px 12px;
                font-size: 0.9rem;
            }
        }

    </style>
</head>
<body>

<!-- 난이도 선택 및 컨트롤 영역 -->
<div id="gameControls">
    <div class="flex items-center">
        <label for="difficultySelect" class="text-white mr-2">난이도:</label>
        <select id="difficultySelect" class="text-black">
            <option value="easy">쉬움</option>
            <option value="normal" selected>보통</option>
            <option value="hard">어려움</option>
        </select>
    </div>
    
    <!-- 버튼들을 그룹화하고 오른쪽 정렬 및 줄 바꿈 처리 -->
    <div class="flex space-x-2 mt-2 sm:mt-0">
        <!-- 라운드 재시작 버튼 (점수 유지) -->
        <button id="resetRoundButton" class="action-button mt-0 bg-orange-500 hover:bg-orange-600">라운드 재시작</button>
        <!-- 전체 게임 재시작 버튼 (점수 리셋) -->
        <button id="forceRestartButton" class="action-button mt-0 bg-red-600 hover:bg-red-700">전체 재시작</button>
    </div>
</div>


<div id="gameContainer" class="relative">
    <!-- 스코어 보드 -->
    <div id="scoreBoard">
        <div class="score-item">
            <span id="aiLabel">AI (빨강)</span>
            <span id="aiScore">0</span>
        </div>
        <div class="score-item">
            <span id="playerScore">0</span>
            <span id="playerLabel">(파랑) 나</span>
        </div>
    </div>
    
    <!-- 에어하키 캔버스 -->
    <canvas id="airHockeyCanvas"></canvas>

    <!-- 메시지 박스 (alert 대체) -->
    <div id="messageBox">
        <p id="messageText"></p>
        <button id="restartButton" class="action-button">다시 시작</button>
    </div>
</div>


<script>
    // 전역 상수 및 설정
    const canvas = document.getElementById('airHockeyCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('gameContainer');
    const messageBox = document.getElementById('messageBox');
    const messageText = document.getElementById('messageText');
    const restartButton = document.getElementById('restartButton');
    const forceRestartButton = document.getElementById('forceRestartButton');
    const resetRoundButton = document.getElementById('resetRoundButton'); // 라운드 재시작 버튼 참조 추가
    const playerScoreElement = document.getElementById('playerScore');
    const aiScoreElement = document.getElementById('aiScore');
    const difficultySelect = document.getElementById('difficultySelect'); // 난이도 셀렉터 참조

    let gameLoopId;
    let isGameOver = false;
    let width, height; // 캔버스 크기
    let centerLineY;

    // 게임 요소 크기 (캔버스 크기에 비례하여 설정)
    let PUCK_RADIUS_RATIO = 0.03;
    let MALLET_RADIUS_RATIO = 0.06;
    let GOAL_WIDTH_RATIO = 0.3;

    let puck = {};
    let player1 = {}; // 아래쪽 (파란색)
    let player2_ai = {}; // 위쪽 (빨간색)
    let score = { player: 0, ai: 0, max: 7 };

    // AI 난이도 설정
    let AI_CONFIG = {}; // 현재 난이도 설정을 저장할 객체

    const DIFFICULTY_SETTINGS = {
        easy: {
            speed: 0.5, // 느린 반응 속도
            defenseYRatio: 0.1 // 더 뒤로 물러서서 수비
        },
        normal: {
            speed: 0.8, // 보통 반응 속도
            defenseYRatio: 0.2 // 중간 수비 위치
        },
        hard: {
            speed: 1.2, // 빠른 반응 속도
            defenseYRatio: 0.3 // 더 앞으로 나와서 공격적 수비
        }
    };
    
    // === 난이도 설정 적용 함수 ===
    function applyDifficulty() {
        const difficulty = difficultySelect.value;
        AI_CONFIG = DIFFICULTY_SETTINGS[difficulty];
        // 선택된 난이도 값이 유효하지 않은 경우 기본값 (normal) 적용
        if (!AI_CONFIG) {
            AI_CONFIG = DIFFICULTY_SETTINGS['normal'];
            difficultySelect.value = 'normal';
        }
    }


    // === 초기화 및 리사이즈 함수 ===
    function resizeCanvas() {
        // 컨테이너 크기에 맞춰 캔버스 크기 조정
        const containerRect = container.getBoundingClientRect();
        width = containerRect.width;
        height = containerRect.height * 0.9; // 스코어보드를 위한 공간 확보 (10%)

        // 최소 크기 보장 (매우 작은 화면에서도 게임이 가능하도록)
        const minSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
        if (width < minSize) {
            width = minSize;
        }
        if (height < minSize * 0.67) {
            height = minSize * 0.67;
        }

        canvas.width = width;
        canvas.height = height;
        centerLineY = height / 2;

        // 요소 크기 및 위치 조정 (화면 크기에 따라 비례 조정)
        const sizeMultiplier = Math.min(width / 300, height / 450); // 기준 크기 대비 비율
        puck.r = Math.max(width * PUCK_RADIUS_RATIO, 8); // 최소 크기 보장
        player1.r = Math.max(width * MALLET_RADIUS_RATIO, 12);
        player2_ai.r = Math.max(width * MALLET_RADIUS_RATIO, 12);

        // 초기 위치 설정 (항상 가운데)
        resetPuck();
        resetMallets();
    }

    // === 게임 요소 초기화 및 리셋 함수 ===
    function resetPuck() {
        puck = {
            x: width / 2,
            y: centerLineY,
            r: puck.r || width * PUCK_RADIUS_RATIO,
            vx: 0,
            vy: 0,
            friction: 0.99, // 마찰
            maxSpeed: 15 * (width / 600) // 화면 크기에 따라 속도 보정
        };
    }

    function resetMallets() {
        // 플레이어 (아래쪽)
        player1.x = width / 2;
        player1.y = height * 0.75;
        player1.r = player1.r || width * MALLET_RADIUS_RATIO;
        player1.vx = 0;
        player1.vy = 0;
        player1.isDragging = false;

        // AI (위쪽)
        player2_ai.x = width / 2;
        player2_ai.y = height * 0.25;
        player2_ai.r = player2_ai.r || width * MALLET_RADIUS_RATIO;
        player2_ai.vx = 0;
        player2_ai.vy = 0;
    }

    // 전체 게임 재시작 (점수 리셋)
    function initializeGame() {
        // 난이도 설정 적용
        applyDifficulty();

        // 캔버스 크기 및 요소 초기화
        resizeCanvas();
        resetPuck();
        resetMallets();
        score.player = 0; // 점수 리셋
        score.ai = 0;
        isGameOver = false;
        playerScoreElement.textContent = 0;
        aiScoreElement.textContent = 0;
        messageBox.style.display = 'none';

        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
        }
        gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // 라운드 재시작 (점수 유지)
    function resetRound() {
        // 캔버스 크기 및 요소 초기화
        resizeCanvas();
        resetPuck();
        resetMallets();
        isGameOver = false;
        messageBox.style.display = 'none';
        
        // 점수는 유지되므로 업데이트 불필요
        
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
        }
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    // 디바운스된 리사이즈 이벤트 처리 (성능 최적화)
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            resizeCanvas();
            resetPuck(); // 요소 크기 변경 후 리셋
            resetMallets();
        }, 100); // 100ms 지연으로 과도한 리사이즈 이벤트 방지
    });

    // 화면 회전 감지 (모바일)
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            resizeCanvas();
            resetPuck();
            resetMallets();
        }, 200); // 화면 회전 완료 후 실행
    });

    // === 그리기 함수 ===
    function drawBoard() {
        // 배경은 이미 CSS로 설정됨

        // 중앙선
        ctx.beginPath();
        // [FIX] CSS 변수 사용 시 getComputedStyle을 사용하도록 수정
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line-color');
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.arc(width / 2, centerLineY, width * 0.2, 0, 2 * Math.PI); // 중앙 원
        ctx.moveTo(0, centerLineY);
        ctx.lineTo(width, centerLineY);
        ctx.stroke();
        ctx.setLineDash([]); // 대시 제거

        // 골대 (위)
        let goalWidth = width * GOAL_WIDTH_RATIO;
        ctx.beginPath();
        // [FIX] CSS 변수 사용 시 getComputedStyle을 사용하도록 수정
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-color'); // 배경색과 동일
        ctx.fillRect(width / 2 - goalWidth / 2, -1, goalWidth, 10);
        // [FIX] CSS 변수 사용 시 getComputedStyle을 사용하도록 수정
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line-color');
        ctx.lineWidth = 4;
        ctx.strokeRect(width / 2 - goalWidth / 2, 0, goalWidth, 10); // 골대 입구

        // 골대 (아래)
        ctx.beginPath();
        // [FIX] CSS 변수 사용 시 getComputedStyle을 사용하도록 수정
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-color');
        ctx.fillRect(width / 2 - goalWidth / 2, height - 9, goalWidth, 10);
        // [FIX] CSS 변수 사용 시 getComputedStyle을 사용하도록 수정
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line-color');
        ctx.lineWidth = 4;
        ctx.strokeRect(width / 2 - goalWidth / 2, height - 10, goalWidth, 10); // 골대 입구
    }

    function drawCircle(x, y, r, color, glow = true) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = color;

        if (glow) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.fill();
        ctx.closePath();
        ctx.shadowBlur = 0; // 그림자 리셋
    }

    function draw() {
        // 캔버스 클리어
        ctx.clearRect(0, 0, width, height);

        // 보드 그리기
        drawBoard();

        // AI 패들 그리기 (빨강)
        drawCircle(player2_ai.x, player2_ai.y, player2_ai.r, getComputedStyle(document.documentElement).getPropertyValue('--ai-color'));

        // 플레이어 패들 그리기 (파랑)
        drawCircle(player1.x, player1.y, player1.r, getComputedStyle(document.documentElement).getPropertyValue('--player-color'));

        // 퍽 그리기 (흰색)
        drawCircle(puck.x, puck.y, puck.r, getComputedStyle(document.documentElement).getPropertyValue('--puck-color'));
    }

    // === 업데이트 및 게임 로직 함수 ===

    function limitSpeed(entity) {
        let speed = Math.sqrt(entity.vx * entity.vx + entity.vy * entity.vy);
        if (speed > puck.maxSpeed) {
            let ratio = puck.maxSpeed / speed;
            entity.vx *= ratio;
            entity.vy *= ratio;
        }
    }

    function updatePuck() {
        // 마찰 적용
        puck.vx *= puck.friction;
        puck.vy *= puck.friction;

        // 퍽 위치 업데이트
        puck.x += puck.vx;
        puck.y += puck.vy;

        limitSpeed(puck);

        // 경계 충돌 처리 (좌/우 벽)
        if (puck.x - puck.r < 0) {
            puck.vx *= -1;
            puck.x = puck.r;
        } else if (puck.x + puck.r > width) {
            puck.vx *= -1;
            puck.x = width - puck.r;
        }

        // 경계 충돌 처리 (상/하 벽, 골대 제외)
        let goalWidth = width * GOAL_WIDTH_RATIO;
        let goalLeft = width / 2 - goalWidth / 2;
        let goalRight = width / 2 + goalWidth / 2;

        // 위쪽 경계 (AI 골대)
        if (puck.y - puck.r < 0) {
            if (puck.x < goalLeft || puck.x > goalRight) {
                puck.vy *= -1;
                puck.y = puck.r;
            } else {
                // 골인 (AI 골대에 들어감 -> 플레이어 득점)
                scoreGoal('player'); 
            }
        }

        // 아래쪽 경계 (플레이어 골대)
        if (puck.y + puck.r > height) {
            if (puck.x < goalLeft || puck.x > goalRight) {
                puck.vy *= -1;
                puck.y = height - puck.r;
            } else {
                // 골인 (플레이어 골대에 들어감 -> AI 득점)
                scoreGoal('ai'); 
            }
        }
    }

    function checkCollision(entity1, entity2) {
        let dx = entity1.x - entity2.x;
        let dy = entity1.y - entity2.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        let minDistance = entity1.r + entity2.r;

        if (distance < minDistance) {
            // 충돌 발생
            let angle = Math.atan2(dy, dx);
            let targetX = entity2.x + Math.cos(angle) * minDistance;
            let targetY = entity2.y + Math.sin(angle) * minDistance;
            let ax = (targetX - entity1.x) * 0.1; // 겹침 보정
            let ay = (targetY - entity1.y) * 0.1;
            entity1.x += ax;
            entity1.y += ay;

            // 속도 반사 및 전달 (탄성 충돌)
            let nDx = dx / distance;
            let nDy = dy / distance;
            let vp1 = nDx * entity1.vx + nDy * entity1.vy;
            let vp2 = nDx * entity2.vx + nDy * entity2.vy;

            let finalVp1 = ((vp1 * (1 - 1) + 2 * 1 * vp2) / (1 + 1)) * 0.95; // 1:1 질량 가정, 0.95는 에너지 손실
            entity1.vx += nDx * (finalVp1 - vp1) * 1.5; // 패들 속도 전달을 위해 1.5배 증가
            entity1.vy += nDy * (finalVp1 - vp1) * 1.5;

            // 퍽에 패들의 속도 추가 (패들 속도가 퍽에 미치는 영향 증가)
            entity1.vx += entity2.vx * 0.5;
            entity1.vy += entity2.vy * 0.5;

            limitSpeed(entity1);
        }
    }

    function updatePlayerMallet() {
        // 플레이어 패들 속도는 터치 이벤트에서 계산됨 (현재는 단순히 위치만 업데이트)

        // 패들을 플레이어 영역(하단 절반) 내로 제한
        let malletR = player1.r;
        player1.x = Math.max(malletR, Math.min(width - malletR, player1.x));
        player1.y = Math.max(centerLineY + malletR, Math.min(height - malletR, player1.y));
    }

    function updateAIMallet() {
        // 1. 목표 위치 설정
        let targetX, targetY;
        // AI_CONFIG.defenseYRatio 사용
        let aiDefenseY = height * AI_CONFIG.defenseYRatio; 
        let malletR = player2_ai.r;

        if (puck.y - puck.r > centerLineY) {
            // 퍽이 플레이어 영역에 있을 때: 수비 모드 (골대 중앙 방어)
            targetX = width / 2;
            targetY = aiDefenseY;
        } else {
            // 퍽이 AI 영역에 있을 때: 공격 모드 (퍽을 향해 이동)
            targetX = puck.x;
            targetY = puck.y;

            // AI가 중앙선을 넘지 않도록 제한
            targetY = Math.max(malletR, Math.min(centerLineY - malletR, targetY));
        }

        // 2. AI 움직임 계산
        let dx = targetX - player2_ai.x;
        let dy = targetY - player2_ai.y;
        let dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 1) {
            // AI_CONFIG.speed 사용
            let speed = dist * 0.15 * AI_CONFIG.speed; 
            if (speed > puck.maxSpeed) {
                speed = puck.maxSpeed;
            }

            // 이전 속도를 저장하여 퍽에 전달될 수 있도록 함
            player2_ai.vx = (dx / dist) * speed;
            player2_ai.vy = (dy / dist) * speed;

            player2_ai.x += player2_ai.vx;
            player2_ai.y += player2_ai.vy;
        } else {
            player2_ai.vx = 0;
            player2_ai.vy = 0;
        }

        // 3. AI 영역 제한
        player2_ai.x = Math.max(malletR, Math.min(width - malletR, player2_ai.x));
        player2_ai.y = Math.max(malletR, Math.min(centerLineY - malletR, player2_ai.y));
    }


    function update() {
        if (isGameOver) return;

        // AI 패들 업데이트
        updateAIMallet();
        
        // 플레이어 패들 업데이트 (터치 이벤트에 의해 위치는 이미 업데이트됨, 충돌 제한만)
        updatePlayerMallet();

        // 충돌 체크 (Puck vs Player)
        checkCollision(puck, player1);
        checkCollision(puck, player2_ai);

        // 퍽 업데이트 (움직임 및 벽 충돌, 골인)
        updatePuck();
    }

    // === 스코어 및 게임 종료 처리 함수 ===
    function scoreGoal(scorer) {
        if (scorer === 'ai') {
            score.ai++;
            aiScoreElement.textContent = score.ai;
            showMessage('AI 득점! (빨강)');
        } else { // scorer === 'player'
            score.player++;
            playerScoreElement.textContent = score.player;
            showMessage('나 득점! (파랑)');
        }

        // 퍽과 패들 리셋
        resetPuck();
        resetMallets();

        // 승리 조건 확인
        if (score.player >= score.max || score.ai >= score.max) {
            endGame();
        }
    }

    function endGame() {
        isGameOver = true;
        cancelAnimationFrame(gameLoopId);
        let winner = score.player >= score.max ? '나 (파랑)' : 'AI (빨강)';
        messageText.innerHTML = `승리자는 ${winner} 입니다!`;
        messageBox.style.display = 'block';
    }

    function showMessage(msg) {
        messageText.textContent = msg;
        messageBox.style.display = 'block';
        
        // 1초 후 메시지 숨기기 (게임 오버 시 제외)
        if (!isGameOver) {
            setTimeout(() => {
                if (!isGameOver) {
                    messageBox.style.display = 'none';
                }
            }, 1000);
        }
    }

    // === 게임 루프 ===
    function gameLoop() {
        if (!isGameOver) {
            update();
            draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    // === 터치 이벤트 처리 ===
    let lastTouchX = player1.x;
    let lastTouchY = player1.y;

    function handleTouchStart(e) {
        e.preventDefault();
        if (isGameOver) return;

        let rect = canvas.getBoundingClientRect();
        // [FIX] e.touches가 정의되지 않았을 경우 (마우스 이벤트), e 자체를 사용하도록 수정
        const pointer = e.touches ? e.touches[0] : e;
        
        // 캔버스 좌표로 변환 (화면 크기 변화에 대응)
        let touchX = (pointer.clientX - rect.left) * (width / rect.width);
        let touchY = (pointer.clientY - rect.top) * (height / rect.height);

        // 플레이어 패들 영역에 터치/클릭했는지 확인 (터치 영역을 더 크게)
        let dx = touchX - player1.x;
        let dy = touchY - player1.y;
        let touchRadius = Math.max(player1.r * 2, 30); // 최소 터치 영역 보장
        if (Math.sqrt(dx * dx + dy * dy) < touchRadius) {
            player1.isDragging = true;
            lastTouchX = touchX;
            lastTouchY = touchY;
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!player1.isDragging || isGameOver) return;

        let rect = canvas.getBoundingClientRect();
        // [FIX] e.touches가 정의되지 않았을 경우 (마우스 이벤트), e 자체를 사용하도록 수정
        const pointer = e.touches ? e.touches[0] : e;
        
        // 캔버스 좌표로 변환 (화면 크기 변화에 대응)
        let touchX = (pointer.clientX - rect.left) * (width / rect.width);
        let touchY = (pointer.clientY - rect.top) * (height / rect.height);

        // 패들 속도 계산 (터치 이동량 기반, 화면 크기에 따라 조정)
        const speedMultiplier = Math.min(width / 300, 1); // 작은 화면에서 속도 조정
        player1.vx = (touchX - lastTouchX) * 0.5 * speedMultiplier;
        player1.vy = (touchY - lastTouchY) * 0.5 * speedMultiplier;

        // 패들 위치 업데이트
        player1.x = touchX;
        player1.y = touchY;

        lastTouchX = touchX;
        lastTouchY = touchY;
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        player1.isDragging = false;
    }

    // === 이벤트 리스너 등록 ===
    canvas.addEventListener('touchstart', handleTouchStart, false);
    canvas.addEventListener('touchmove', handleTouchMove, false);
    canvas.addEventListener('touchend', handleTouchEnd, false);
    
    // 마우스 이벤트도 지원 (데스크톱 테스트용)
    canvas.addEventListener('mousedown', handleTouchStart, false);
    canvas.addEventListener('mousemove', (e) => {
        // 마우스 왼쪽 버튼(buttons === 1)이 눌려있을 때만 이동 처리
        if (e.buttons === 1) { handleTouchMove(e); }
    }, false);
    canvas.addEventListener('mouseup', handleTouchEnd, false);

    restartButton.addEventListener('click', initializeGame);
    forceRestartButton.addEventListener('click', initializeGame); // 전체 게임 재시작 이벤트
    resetRoundButton.addEventListener('click', resetRound); // 라운드 재시작 이벤트 추가
    // 난이도 변경 시 게임 재시작
    difficultySelect.addEventListener('change', initializeGame); 


    // 초기화 및 게임 시작
    window.onload = initializeGame;

</script>

</body>
</html>
