<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>모바일 에어하키 (PvP 모드 추가)</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 사용 설정 (Tailwind 기본 폰트) */
        :root {
            --board-color: #0b1c31; /* 진한 남색 배경 */
            --line-color: #2a588b; /* 보드 라인 색상 */
            --player-color: #4a90e2; /* 플레이어 1/나 (파란색) */
            --player2-color: #e24a4a; /* 플레이어 2/AI (빨간색) */
            --puck-color: #e6e6e6; /* 퍽 색상 */
            --max-velocity: 15;
            font-family: 'Inter', sans-serif;
        }

        body {
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            padding: 10px;
        }

        #gameControls {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-wrap: wrap; 
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 10px;
            color: white;
            font-size: 1rem;
        }

        .control-group {
            display: flex;
            align-items: center;
            margin-right: 15px;
            margin-bottom: 10px;
        }
        
        @media (min-width: 640px) {
            .control-group {
                margin-bottom: 0;
            }
        }


        #gameContainer {
            width: 100%;
            max-width: 600px; 
            aspect-ratio: 1 / 1.5; 
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 1rem;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            background-color: var(--board-color);
        }

        canvas {
            background-color: var(--board-color);
            border-radius: 1rem;
            touch-action: none; 
        }

        #scoreBoard {
            padding: 0.75rem;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .score-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #player2Score { color: var(--player2-color); } /* AI/P2 */
        #player1Score { color: var(--player-color); } /* P1 */

        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            display: none;
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .action-button {
            margin-top: 15px;
            padding: 8px 15px; /* 버튼 크기 조정 */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem; /* 폰트 크기 조정 */
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px #00000030;
            white-space: nowrap; /* 버튼 텍스트 줄바꿈 방지 */
        }

        .action-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #00000030;
        }

        #restartButton {
            background-color: #4CAF50; 
            color: white;
        }

        #restartButton:hover {
            background-color: #45a049;
        }
        
        #difficultySelect, #modeSelect {
            padding: 5px 10px;
            border-radius: 5px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            font-size: 0.9rem;
        }

    </style>
</head>
<body>

<!-- 게임 모드, 난이도, 재시작 컨트롤 영역 -->
<div id="gameControls">
    <!-- 모드 선택 -->
    <div class="control-group">
        <label for="modeSelect" class="text-white mr-2">모드:</label>
        <select id="modeSelect" class="text-black">
            <option value="ai">Player vs AI</option>
            <option value="pvp">Player vs Player</option>
        </select>
    </div>

    <!-- 난이도 선택 (AI 모드에서만 표시됨) -->
    <div id="difficultyControl" class="control-group">
        <label for="difficultySelect" class="text-white mr-2">난이도:</label>
        <select id="difficultySelect" class="text-black">
            <option value="easy">쉬움</option>
            <option value="normal" selected>보통</option>
            <option value="hard">어려움</option>
        </select>
    </div>
    
    <!-- 버튼 그룹 -->
    <div class="flex space-x-2 flex-wrap sm:flex-nowrap justify-end ml-auto">
        <!-- 라운드 재시작 버튼 (점수 유지) -->
        <button id="resetRoundButton" class="action-button mt-0 bg-orange-500 hover:bg-orange-600">라운드 재시작</button>
        <!-- 전체 게임 재시작 버튼 (점수 리셋) -->
        <button id="forceRestartButton" class="action-button mt-0 bg-red-600 hover:bg-red-700">전체 재시작</button>
    </div>
</div>


<div id="gameContainer" class="relative">
    <!-- 스코어 보드 -->
    <div id="scoreBoard">
        <div class="score-item">
            <span id="player2Label">AI (빨강)</span>
            <span id="player2Score">0</span>
        </div>
        <div class="score-item">
            <span id="player1Score">0</span>
            <span id="player1Label">(파랑) 나</span>
        </div>
    </div>
    
    <!-- 에어하키 캔버스 -->
    <canvas id="airHockeyCanvas"></canvas>

    <!-- 메시지 박스 (alert 대체) -->
    <div id="messageBox">
        <p id="messageText"></p>
        <button id="restartButton" class="action-button">다시 시작</button>
    </div>
</div>


<script>
    // 전역 상수 및 설정
    const canvas = document.getElementById('airHockeyCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('gameContainer');
    const messageBox = document.getElementById('messageBox');
    const messageText = document.getElementById('messageText');
    const restartButton = document.getElementById('restartButton');
    const forceRestartButton = document.getElementById('forceRestartButton');
    const resetRoundButton = document.getElementById('resetRoundButton'); 
    const player1ScoreElement = document.getElementById('player1Score');
    const player2ScoreElement = document.getElementById('player2Score');
    const player2Label = document.getElementById('player2Label'); // P2/AI 라벨
    
    const modeSelect = document.getElementById('modeSelect'); // 모드 셀렉터
    const difficultySelect = document.getElementById('difficultySelect'); 
    const difficultyControl = document.getElementById('difficultyControl'); // 난이도 컨트롤 div

    let gameLoopId;
    let isGameOver = false;
    let currentMode = 'ai'; // 'ai' 또는 'pvp'
    let width, height; 
    let centerLineY;

    // 게임 요소 크기 (캔버스 크기에 비례하여 설정)
    let PUCK_RADIUS_RATIO = 0.03;
    let MALLET_RADIUS_RATIO = 0.06;
    let GOAL_WIDTH_RATIO = 0.3;

    let puck = {};
    let player1 = {}; // 아래쪽 (파란색)
    let player2 = {}; // 위쪽 (빨간색 - AI 또는 P2)
    let score = { player1: 0, player2: 0, max: 7 };

    // 멀티터치를 위한 매핑 (터치 ID와 패들 매핑)
    const activeTouches = new Map(); // Map<touchIdentifier, playerObject>

    // AI 난이도 설정
    let AI_CONFIG = {}; 

    const DIFFICULTY_SETTINGS = {
        easy: {
            speed: 0.5, 
            defenseYRatio: 0.1 
        },
        normal: {
            speed: 0.8, 
            defenseYRatio: 0.2 
        },
        hard: {
            speed: 1.2, 
            defenseYRatio: 0.3 
        }
    };
    
    // === 난이도 설정 적용 함수 ===
    function applyDifficulty() {
        const difficulty = difficultySelect.value;
        AI_CONFIG = DIFFICULTY_SETTINGS[difficulty];
        if (!AI_CONFIG) {
            AI_CONFIG = DIFFICULTY_SETTINGS['normal'];
            difficultySelect.value = 'normal';
        }
    }

    // === UI 업데이트 함수 (모드에 따라 라벨 변경) ===
    function updateUIForMode() {
        currentMode = modeSelect.value;
        if (currentMode === 'ai') {
            player2Label.textContent = 'AI (빨강)';
            difficultyControl.style.display = 'flex';
        } else { // pvp
            player2Label.textContent = '플레이어 2 (빨강)';
            difficultyControl.style.display = 'none'; // PvP 모드에서는 난이도 숨김
        }
    }


    // === 초기화 및 리사이즈 함수 ===
    function resizeCanvas() {
        width = container.clientWidth;
        height = container.clientHeight * 0.9; 

        canvas.width = width;
        canvas.height = height;
        centerLineY = height / 2;

        puck.r = width * PUCK_RADIUS_RATIO;
        player1.r = width * MALLET_RADIUS_RATIO;
        player2.r = width * MALLET_RADIUS_RATIO;

        resetPuck();
        resetMallets();
    }

    // === 게임 요소 초기화 및 리셋 함수 ===
    function resetPuck() {
        puck = {
            x: width / 2,
            y: centerLineY,
            r: puck.r || width * PUCK_RADIUS_RATIO,
            vx: 0,
            vy: 0,
            friction: 0.99, 
            maxSpeed: 15 * (width / 600) 
        };
    }

    function resetMallets() {
        // 플레이어 1 (아래쪽)
        player1.x = width / 2;
        player1.y = height * 0.75;
        player1.r = player1.r || width * MALLET_RADIUS_RATIO;
        player1.vx = 0;
        player1.vy = 0;
        player1.isDragging = false;
        player1.isUser = true; // 사용자 조작 가능

        // 플레이어 2 / AI (위쪽)
        player2.x = width / 2;
        player2.y = height * 0.25;
        player2.r = player2.r || width * MALLET_RADIUS_RATIO;
        player2.vx = 0;
        player2.vy = 0;
        player2.isDragging = false;
        player2.isUser = (currentMode === 'pvp'); // PvP일 때만 사용자 조작 가능
    }

    // 전체 게임 재시작 (점수 리셋)
    function initializeGame() {
        updateUIForMode(); // 모드 및 UI 업데이트
        
        if (currentMode === 'ai') {
            applyDifficulty();
        }

        resizeCanvas();
        resetPuck();
        resetMallets();
        score.player1 = 0; 
        score.player2 = 0;
        isGameOver = false;
        player1ScoreElement.textContent = 0;
        player2ScoreElement.textContent = 0;
        messageBox.style.display = 'none';
        activeTouches.clear(); // 터치 상태 초기화

        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
        }
        gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // 라운드 재시작 (점수 유지)
    function resetRound() {
        updateUIForMode(); // 모드 및 UI 업데이트 (점수 유지이므로 모드 변경은 없겠지만 안전하게)

        resizeCanvas();
        resetPuck();
        resetMallets();
        isGameOver = false;
        messageBox.style.display = 'none';
        activeTouches.clear();

        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
        }
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    window.addEventListener('resize', () => {
        resizeCanvas();
        resetPuck(); 
        resetMallets();
    });

    // === 그리기 함수 ===
    function drawBoard() {
        // 배경은 이미 CSS로 설정됨

        // 중앙선
        ctx.beginPath();
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line-color');
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.arc(width / 2, centerLineY, width * 0.2, 0, 2 * Math.PI); 
        ctx.moveTo(0, centerLineY);
        ctx.lineTo(width, centerLineY);
        ctx.stroke();
        ctx.setLineDash([]); 

        // 골대 (위)
        let goalWidth = width * GOAL_WIDTH_RATIO;
        let goalLeft = width / 2 - goalWidth / 2;
        let goalRight = width / 2 + goalWidth / 2;
        
        ctx.beginPath();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-color'); 
        ctx.fillRect(goalLeft, -1, goalWidth, 10);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line-color');
        ctx.lineWidth = 4;
        ctx.strokeRect(goalLeft, 0, goalWidth, 10); 

        // 골대 (아래)
        ctx.beginPath();
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board-color');
        ctx.fillRect(goalLeft, height - 9, goalWidth, 10);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line-color');
        ctx.lineWidth = 4;
        ctx.strokeRect(goalLeft, height - 10, goalWidth, 10); 
    }

    function drawCircle(x, y, r, color, glow = true) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = color;

        if (glow) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.fill();
        ctx.closePath();
        ctx.shadowBlur = 0; 
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        drawBoard();

        // 플레이어 2 / AI 패들 그리기 (빨강)
        drawCircle(player2.x, player2.y, player2.r, getComputedStyle(document.documentElement).getPropertyValue('--player2-color'));

        // 플레이어 1 패들 그리기 (파랑)
        drawCircle(player1.x, player1.y, player1.r, getComputedStyle(document.documentElement).getPropertyValue('--player-color'));

        // 퍽 그리기 (흰색)
        drawCircle(puck.x, puck.y, puck.r, getComputedStyle(document.documentElement).getPropertyValue('--puck-color'));
    }

    // === 업데이트 및 게임 로직 함수 ===

    function limitSpeed(entity) {
        let speed = Math.sqrt(entity.vx * entity.vx + entity.vy * entity.vy);
        if (speed > puck.maxSpeed) {
            let ratio = puck.maxSpeed / speed;
            entity.vx *= ratio;
            entity.vy *= ratio;
        }
    }

    function updatePuck() {
        // 마찰 적용
        puck.vx *= puck.friction;
        puck.vy *= puck.friction;

        // 퍽 위치 업데이트
        puck.x += puck.vx;
        puck.y += puck.vy;

        limitSpeed(puck);

        // 경계 충돌 처리 (좌/우 벽)
        if (puck.x - puck.r < 0) {
            puck.vx *= -1;
            puck.x = puck.r;
        } else if (puck.x + puck.r > width) {
            puck.vx *= -1;
            puck.x = width - puck.r;
        }

        // 경계 충돌 처리 (상/하 벽, 골대 제외)
        let goalWidth = width * GOAL_WIDTH_RATIO;
        let goalLeft = width / 2 - goalWidth / 2;
        let goalRight = width / 2 + goalWidth / 2;

        // 위쪽 경계 (Player 2 / AI 골대)
        if (puck.y - puck.r < 0) {
            if (puck.x < goalLeft || puck.x > goalRight) {
                puck.vy *= -1;
                puck.y = puck.r;
            } else {
                // 골인 (P2 골대에 들어감 -> Player 1 득점)
                scoreGoal('player1'); 
            }
        }

        // 아래쪽 경계 (Player 1 골대)
        if (puck.y + puck.r > height) {
            if (puck.x < goalLeft || puck.x > goalRight) {
                puck.vy *= -1;
                puck.y = height - puck.r;
            } else {
                // 골인 (P1 골대에 들어감 -> Player 2 득점)
                scoreGoal('player2'); 
            }
        }
    }

    function checkCollision(entity1, entity2) {
        let dx = entity1.x - entity2.x;
        let dy = entity1.y - entity2.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        let minDistance = entity1.r + entity2.r;

        if (distance < minDistance) {
            let angle = Math.atan2(dy, dx);
            let targetX = entity2.x + Math.cos(angle) * minDistance;
            let targetY = entity2.y + Math.sin(angle) * minDistance;
            let ax = (targetX - entity1.x) * 0.1; 
            let ay = (targetY - entity1.y) * 0.1;
            entity1.x += ax;
            entity1.y += ay;

            let nDx = dx / distance;
            let nDy = dy / distance;
            let vp1 = nDx * entity1.vx + nDy * entity1.vy;
            let vp2 = nDx * entity2.vx + nDy * entity2.vy;

            let finalVp1 = ((vp1 * (1 - 1) + 2 * 1 * vp2) / (1 + 1)) * 0.95; 
            entity1.vx += nDx * (finalVp1 - vp1) * 1.5; 
            entity1.vy += nDy * (finalVp1 - vp1) * 1.5;

            entity1.vx += entity2.vx * 0.5;
            entity1.vy += entity2.vy * 0.5;

            limitSpeed(entity1);
        }
    }

    function updatePlayerMallet(player) {
        let malletR = player.r;
        let topLimit = (player === player1) ? centerLineY + malletR : malletR;
        let bottomLimit = (player === player1) ? height - malletR : centerLineY - malletR;

        // 패들을 각자의 영역 내로 제한
        player.x = Math.max(malletR, Math.min(width - malletR, player.x));
        player.y = Math.max(topLimit, Math.min(bottomLimit, player.y));
    }

    function updateAIMallet() {
        if (currentMode === 'pvp') {
            player2.vx = 0;
            player2.vy = 0;
            updatePlayerMallet(player2); // PvP 모드에서는 AI 대신 P2 조작 제한만 적용
            return;
        }

        // AI 모드 로직 (이전과 동일)
        let targetX, targetY;
        let aiDefenseY = height * AI_CONFIG.defenseYRatio; 
        let malletR = player2.r;

        if (puck.y - puck.r > centerLineY) {
            targetX = width / 2;
            targetY = aiDefenseY;
        } else {
            targetX = puck.x;
            targetY = puck.y;
            targetY = Math.max(malletR, Math.min(centerLineY - malletR, targetY));
        }

        let dx = targetX - player2.x;
        let dy = targetY - player2.y;
        let dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 1) {
            let speed = dist * 0.15 * AI_CONFIG.speed; 
            if (speed > puck.maxSpeed) {
                speed = puck.maxSpeed;
            }

            player2.vx = (dx / dist) * speed;
            player2.vy = (dy / dist) * speed;

            player2.x += player2.vx;
            player2.y += player2.vy;
        } else {
            player2.vx = 0;
            player2.vy = 0;
        }

        // AI 영역 제한
        player2.x = Math.max(malletR, Math.min(width - malletR, player2.x));
        player2.y = Math.max(malletR, Math.min(centerLineY - malletR, player2.y));
    }


    function update() {
        if (isGameOver) return;

        // 패들 업데이트
        updatePlayerMallet(player1);
        updateAIMallet(); // AI 로직 또는 PvP 모드 제한 적용
        
        // 충돌 체크
        checkCollision(puck, player1);
        checkCollision(puck, player2);

        // 퍽 업데이트
        updatePuck();
    }

    // === 스코어 및 게임 종료 처리 함수 ===
    function scoreGoal(scorer) {
        let scorerName = '';
        if (scorer === 'player2') {
            score.player2++;
            player2ScoreElement.textContent = score.player2;
            scorerName = player2Label.textContent;
        } else { // scorer === 'player1'
            score.player1++;
            player1ScoreElement.textContent = score.player1;
            scorerName = document.getElementById('player1Label').textContent.replace(/[()]/g, '');
        }

        showMessage(`${scorerName} 득점!`);

        resetPuck();
        resetMallets();

        if (score.player1 >= score.max || score.player2 >= score.max) {
            endGame();
        }
    }

    function endGame() {
        isGameOver = true;
        cancelAnimationFrame(gameLoopId);
        let winnerName = '';
        if (score.player1 >= score.max) {
            winnerName = document.getElementById('player1Label').textContent.replace(/[()]/g, '');
        } else {
            winnerName = player2Label.textContent;
        }
        messageText.innerHTML = `승리자는 ${winnerName} 입니다!`;
        messageBox.style.display = 'block';
    }

    function showMessage(msg) {
        messageText.textContent = msg;
        messageBox.style.display = 'block';
        
        if (!isGameOver) {
            setTimeout(() => {
                if (!isGameOver) {
                    messageBox.style.display = 'none';
                }
            }, 1000);
        }
    }

    // === 게임 루프 ===
    function gameLoop() {
        if (!isGameOver) {
            update();
            draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    // === 터치 이벤트 처리 (멀티터치 지원) ===
    function getPointerPosition(pointer, rect) {
        return {
            x: pointer.clientX - rect.left,
            y: pointer.clientY - rect.top
        };
    }

    // 터치/마우스 시작
    function handleTouchStart(e) {
        e.preventDefault();
        if (isGameOver) return;

        const rect = canvas.getBoundingClientRect();
        const pointers = e.touches ? Array.from(e.touches) : [e]; // 터치 배열 또는 단일 마우스 이벤트

        for (const pointer of pointers) {
            const pos = getPointerPosition(pointer, rect);
            const identifier = e.touches ? pointer.identifier : 'mouse'; // 터치 ID 또는 'mouse'

            // P1 영역 (아래 절반) 확인
            const dx1 = pos.x - player1.x;
            const dy1 = pos.y - player1.y;
            const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            
            // P2 영역 (위쪽 절반) 확인
            const dx2 = pos.x - player2.x;
            const dy2 = pos.y - player2.y;
            const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

            let malletToDrag = null;

            if (dist1 < player1.r * 1.5 && player1.isUser && pos.y > centerLineY) {
                malletToDrag = player1;
            } else if (dist2 < player2.r * 1.5 && player2.isUser && pos.y <= centerLineY) {
                malletToDrag = player2;
            }

            if (malletToDrag && !activeTouches.has(identifier)) {
                malletToDrag.isDragging = true;
                malletToDrag.lastX = pos.x;
                malletToDrag.lastY = pos.y;
                activeTouches.set(identifier, malletToDrag);
            }
        }
    }

    // 터치/마우스 이동
    function handleTouchMove(e) {
        e.preventDefault();
        if (isGameOver) return;
        
        const rect = canvas.getBoundingClientRect();
        const pointers = e.touches ? Array.from(e.touches) : [e];

        for (const pointer of pointers) {
            const identifier = e.touches ? pointer.identifier : 'mouse';

            if (activeTouches.has(identifier)) {
                const mallet = activeTouches.get(identifier);
                const pos = getPointerPosition(pointer, rect);

                // 속도 계산
                mallet.vx = (pos.x - mallet.lastX) * 0.5;
                mallet.vy = (pos.y - mallet.lastY) * 0.5;

                // 위치 업데이트
                mallet.x = pos.x;
                mallet.y = pos.y;

                mallet.lastX = pos.x;
                mallet.lastY = pos.y;
            }
        }
    }

    // 터치/마우스 종료
    function handleTouchEnd(e) {
        e.preventDefault();
        
        const changedTouches = e.changedTouches ? Array.from(e.changedTouches) : [e];

        for (const pointer of changedTouches) {
            const identifier = e.changedTouches ? pointer.identifier : 'mouse';

            if (activeTouches.has(identifier)) {
                const mallet = activeTouches.get(identifier);
                mallet.isDragging = false;
                activeTouches.delete(identifier);
            }
        }
    }

    // === 이벤트 리스너 등록 ===
    canvas.addEventListener('touchstart', handleTouchStart, false);
    canvas.addEventListener('touchmove', handleTouchMove, false);
    canvas.addEventListener('touchend', handleTouchEnd, false);
    
    // 마우스 이벤트도 지원 (데스크톱 테스트용)
    canvas.addEventListener('mousedown', handleTouchStart, false);
    canvas.addEventListener('mousemove', (e) => {
        if (e.buttons === 1) { handleTouchMove(e); } // 마우스 왼쪽 버튼 클릭 시
    }, false);
    canvas.addEventListener('mouseup', handleTouchEnd, false);

    restartButton.addEventListener('click', initializeGame);
    forceRestartButton.addEventListener('click', initializeGame); 
    resetRoundButton.addEventListener('click', resetRound); 
    
    // 모드/난이도 변경 시 게임 재시작
    modeSelect.addEventListener('change', initializeGame); 
    difficultySelect.addEventListener('change', initializeGame); 


    // 초기화 및 게임 시작
    window.onload = initializeGame;

</script>

</body>
</html>
